essa √© a explica√ß√£o do que √© o jogo:   # **ROOT EVOLUTION**

## üéÆ **Um Jogo de Terminal Hacker no Estilo Mr. Robot**

### **"Eles pensam que o c√≥digo √© apenas instru√ß√µes para m√°quinas. Eles n√£o entendem que o c√≥digo √© a linguagem do poder."**

---

## üìñ **SINOPSE**

**ROOT EVOLUTION** √© uma experi√™ncia imersiva de terminal que coloca voc√™ na pele de um jovem hacker black hat em forma√ß√£o. A hist√≥ria come√ßa com uma suspeita de trai√ß√£o pessoal e evolui para uma conspira√ß√£o que amea√ßa redefinir o equil√≠brio de poder no pa√≠s.

Depois de descobrir, atrav√©s de suas pr√≥prias habilidades de hacking, que sua namorada o tra√≠a, voc√™ mergulha em uma depress√£o profunda apenas para emergir com um novo prop√≥sito: usar o c√≥digo n√£o como ferramenta, mas como arma. Seu objetivo? Derrubar o sistema governamental corrupto e instalar uma utopia an√°rquica.

Mas quando um grupo misterioso chamado **"Os An√¥nimos"** recruta voc√™ para sua causa, uma verdade perturbadora emerge: eles n√£o querem destruir o governo. Eles querem **control√°-lo**.


---
## **O JOGO**

A tela do jogo ser√° toda baseada no terminal Kali Linux, aonde acontecer√£o os cap√≠tulos. Cada cap√≠tulo vai contar com uma parte dramatica baseada na trama central do jogo. Os desafios no jogo ser√£o baseados na trama do jogo por exemplo: O protagonista vai hackear o computador da namorada e os jogadores √© quem tem que digitar os comandos no terminal criado. A cada capitulo aumenta a dificuldade do que se tem que fazer mas cada objetivo ser√° ensinado passo a passo para que o jogador consiga ir melhorando at√© o ponto aonde poucas dicas ser√£o necess√°rias. O jogo vai contar com um Manual Completo de como hackear, com comandos linux e ferramentas reais de hacking. O jogo √© todo em portugu√ªes e traz elementos reais de hacking e pol√≠tica no Brasil. Tudo baseado na realidade

Este √© um exemplo em c√≥digo do que ser√£o os cap√≠tulos e como deve se desenvolver. Tem que ter ritmo e respiro:

def exibir_proximidade(estagio):
"""Exibe visualmente e sonoramente o qu√£o perto a Juliana est√°."""
estagios = [
"[ ] Juliana est√° sentando na cama...",
"[== ] Juliana cal√ßou os chinelos...",
"[==== ] Ela est√° caminhando pelo corredor...",
"[====== ] Ela est√° colocando a m√£o na ma√ßaneta...",
"[======== ] A porta est√° abrindo!",
"[==========] ELA EST√Å ATR√ÅS DE VOC√ä!"
]
idx = min(estagio, len(estagios) - 1)
vol_coracao = 0.2 + (estagio * 0.15)
cor = VERMELHO if estagio >= 3 else CINZA
print(f"\n{cor}{NEGRITO}PROXIMIDADE DE JULIANA:{RESET}")
print(f"{cor}{estagios[idx]}{RESET}\n")
def _prompt_sob_pressao(cmd_expect, state, escolha_nome):
estagio_atual = 0
limite_estagios = 5
print(f"\n{VERMELHO}{NEGRITO}# [ ALERTA ]: ELA EST√Å VINDO!{RESET}")
print(f"{CINZA}Tarefa: {escolha_nome}{RESET}")
while estagio_atual < limite_estagios:
exibir_proximidade(estagio_atual)
print(f"{VERDE}# COMANDO ALVO: {cmd_expect}{RESET}")
prefixo = f"{VERMELHO}>>> {RESET}"
cmd = input(prefixo + prompt_kali(state.codinome if hasattr(state, 'codinome') else "hacker")).strip()
if cmd == "manual":
from core.manual import exibir_manual
exibir_manual()
print(f"\n{VERMELHO}# VOC√ä PERDEU TEMPO OLHANDO O MANUAL!{RESET}")
estagio_atual += 1
continue
if cmd == cmd_expect:
return "SUCESSO"
else:
estagio_atual += 1
state.registrar_falha(5)
if state.game_over:
return "GAMEOVER"
print(f"\n{VERMELHO}{NEGRITO}[!] ERRO! ELA OUVIU O TECLADO E APERTOU O PASSO!{RESET}")
time.sleep(0.5)
return "TIMEOUT"
def iniciar(state):
header_kali_v2()
# --- PARTE 1: INVESTIGA√á√ÉO ---

digitar("O caf√© esfriou h√° horas. O sil√™ncio √© quebrado apenas pelo cooler do PC...", cor=CIANO, delay=0.08)
time.sleep(1.2)
digitar("Juliana dorme ao lado. Ela n√£o faz ideia do que estou prestes a descobrir.", cor=CIANO, delay=0.08)
print(f"{CINZA}{'-'*73}{RESET}")
time.sleep(0.8)
if not _prompt_until(
"ssh admin@backup-cloud",
"Vou usar SSH para entrar no servidor 'admin@backup-cloud'.",
state
): return
sucesso("Sess√£o remota estabelecida.")
time.sleep(1)
if not _prompt_until(
"cd Private",
"Vou entrar na pasta 'Private' (cd).",
state
): return
if not _prompt_until(
"ls -a",
"Vou listar os arquivos ocultos (ls -a).",
state
): return
print(f"\n{VERMELHO}.conversa_hotel_nobile.pdf{RESET} | {VERMELHO}.fotos_reserva_dupla.zip{RESET}")
time.sleep(2.5)
print(f"\n{NEGRITO}{VERMELHO}* O RANGER DA CAMA... JULIANA ACORDOU! *{RESET}")
time.sleep(1.5)
digitar("\nJuliana: '...Amor? Ainda acordado? O que voc√™ est√° fazendo?'", cor=BRANCO, delay=0.1)
time.sleep(1.2)
digitar("\nDROGA! Ela est√° vindo em dire√ß√£o √† mesa! R√°pido!", cor=VERMELHO, delay=0.08)
print(f"\n{NEGRITO}--- DECIS√ÉO SOB PRESS√ÉO ---{RESET}")
print(f"{BRANCO}[1]{RESET} EXFILTRAR (Copiar o PDF via SCP)")
print(f"{BRANCO}[2]{RESET} DESTRUIR (Remover tudo via RM)")
escolha = ""
while escolha not in ["1", "2"]:
escolha = input(f"\n{VERMELHO}[ESCOLHA 1 ou 2]: {RESET}").strip()
status = ""
if escolha == "1":
status = _prompt_sob_pressao(
"scp .conversa_hotel_nobile.pdf exfil@drop:~/",
state, "Exfiltrando Evid√™ncias"
)
else:
status = _prompt_sob_pressao(
"rm -rf *",
state, "Limpando o Servidor"
)
if status == "TIMEOUT":
print(f"\n{VERMELHO}Tarde demais... voc√™ ouve o ranger da porta atr√°s de voc√™.{RESET}")
time.sleep(2)
limpar_tela()
header_kali_v2()
print(f"{VERMELHO}{'='*60}\n{'VOC√ä FOI PEGO EM FLAGRANTE':^60}\n{'='*60}{RESET}")
digitar("\nJuliana olha para o monitor. O arquivo do Hotel Nobile est√° aberto.", cor=BRANCO)
digitar("\nJuliana: 'Ent√£o √© isso que voc√™ faz enquanto eu durmo?'", cor=BRANCO)
state.registrar_falha(100)
return
if status == "SUCESSO":
sucesso("\nOPERA√á√ÉO CONCLU√çDA. LOGS LIMPOS.")
time.sleep(1.2)
digitar("\nVoc√™ fecha o notebook no exato segundo em que ela toca no seu ombro.", cor=CIANO)
digitar("Juliana: 'Vem dormir, amor... voc√™ trabalha demais.'", cor=BRANCO)
state.concluiu_capitulo_1 = True
input(f"\n{BRANCO}[Pressione ENTER para desconectar...]{RESET}")
def _prompt_until(cmd_expect, pensamento, state, fatigue=4):
cmd = ""
while cmd != cmd_expect:
print(f"\n{CINZA}# PENSAMENTO: {pensamento}{RESET}")
cmd = input(prompt_kali(state.codinome if hasattr(state, 'codinome') else "hacker")).strip()
if cmd == "manual":
from core.manual import exibir_manual
exibir_manual()
continue
if cmd != cmd_expect:
erro("Comando incorreto. Tente novamente.")
state.registrar_falha(fatigue)
if state.game_over: return False
return True
---

## üë§ **O PROTAGONISTA**

**Nome:** [Nome do Pr√≥prio Usuario] (codinome vari√°vel)  
**Idade:** [Idade escolhida pelo usuario]  
**Localiza√ß√£o:** Bras√≠lia, DF  
**Background:** Estudante de Ci√™ncia da Computa√ß√£o abandonou a faculdade ap√≥s a suspeita de trai√ß√£o da namorada. Para tentar saber a verdade ele invadiu o computador da namorada e descobriu mais coisas al√©m da trai√ß√£o. Descobriu que a namorada esconde segredos e que recebe propina de uma prefeitura em bitcoin. 


**Arco Emocional:**
1. **Inoc√™ncia** ‚Üí Confian√ßa na namorada Juliana
2. **Trauma** ‚Üí Descoberta da trai√ß√£o via hacking
3. **Depress√£o** ‚Üí Isolamento social, perda de prop√≥sito
4. **Descoberta** ‚Üí Encontro com o poder real do c√≥digo
5. **Miss√£o** ‚Üí Objetivo ut√≥pico de derrubar o sistema
6. **Desilus√£o** ‚Üí Descoberta da verdade sobre os An√¥nimos
7. **Escolha** ‚Üí Continuar com os An√¥nimos ou tra√≠-los?

**Habilidade √önica:** Autodidata prod√≠gio - aprendeu hacking avan√ßado em semanas movido pela obsess√£o de provar a trai√ß√£o.

---

## üéØ **SISTEMA DE JOGO**

### **Atributos do Personagem:**

1. **ANONIMATO** (0-100%)
   - Representa sua capacidade de operar sem ser detectado
   - Diminui com erros grosseiros ou ataques diretos
   - Chegando a 0%: Pris√£o ou "desaparecimento"
   - *"Eles n√£o podem prender o que n√£o podem encontrar."*

2. **HABILIDADE T√âCNICA** (0-100%)
   - Determina sucesso em opera√ß√µes complexas
   - Aumenta com miss√µes bem-sucedidas e estudo
   - Alta habilidade = menos tentativas necess√°rias
   - *"O c√≥digo √© minha extens√£o, o terminal minha arma."*

3. **CONSCI√äNCIA** (0-100%)
   - Mede seu entendimento das consequ√™ncias reais
   - Afeta di√°logos e op√ß√µes dispon√≠veis
   - Baixa consci√™ncia = mais op√ß√µes violentas/destrutivas
   - *"Cada linha de c√≥digo tem um impacto no mundo real."*

### **Ferramentas Adquir√≠veis:**
- **VPN/Tor Bundle** ‚Üí Aumenta anonimato temporariamente
- **Dicion√°rio Rainbow** ‚Üí Melhora ataques de for√ßa bruta
- **Burp Suite Clone** ‚Üí Revela vulnerabilidades web
- **Keylogger Custom** ‚Üí Coleta dados de alvos espec√≠ficos
- **Cripto Wallet** ‚Üí Para transa√ß√µes an√¥nimas em Bitcoin

### **Mec√¢nicas Principais:**
- **Comandos Reais de Linux**: Simula√ß√£o aut√™ntica de terminal
- **Sistema de Escolhas Morais**: Cada decis√£o afeta atributos
- **Consequ√™ncias Persistentes**: Erros t√™m impacto em cap√≠tulos futuros
- **Puzzles de Hacking Variados**: SSH, SQLi, cracking, an√°lise forense
- **Sistema de Alerta**: Autoridades se aproximam conforme seu anonimato cai

---

## üìö **ARCO DA HIST√ìRIA**

### **CAP√çTULO 1: "O Protocolo da Trai√ß√£o"**
*Bras√≠lia, 02:47 AM. O quarto escuro, apenas o brilho azulado do laptop. Juliana dorme ao seu lado, alheia. H√° semanas de suspeitas. Hoje, a verdade.*
- **Foco**: Hacking emocional, invas√£o de servidor pessoal
- **Habilidade**: SSH, manipula√ß√£o de arquivos
- **Momento-chave**: Descoberta dos arquivos do Hotel Nobile
- **Decis√£o Cr√≠tica**: Preservar ou destruir as evid√™ncias?
- **Consequ√™ncia**: In√≠cio da jornada hacker ou volta √† normalidade?

### **CAP√çTULO 2: "O Vazio entre os Bits"**
*Tr√™s semanas depois. O apartamento est√° um caos. Garrafas vazias, tela do laptop a √∫nica luz. A depress√£o consome, mas o c√≥digo... o c√≥digo faz sentido.*
- **Foco**: Autoaprendizado, primeiros f√≥runs underground
- **Habilidade**: Criptografia b√°sica, anonimato digital
- **Momento-chave**: Primeiro acesso n√£o autorizado bem-sucedido
- **Decis√£o Cr√≠tica**: Compartilhar descoberta ou manter sigilo?
- **Consequ√™ncia**: Isolamento total ou primeiras conex√µes na dark web?

### **CAP√çTULO 3: "O Primeiro Chamado"**
*Uma mensagem aparece em um f√≥rum fechado: "Vimos seu trabalho. Temos objetivos em comum. Procure por 'fsociety.br'".*
- **Foco**: Contato com os "An√¥nimos", teste de habilidades
- **Habilidade**: SQL Injection, bypass de autentica√ß√£o
- **Momento-chave**: Encontro virtual com o l√≠der (V0id_Walker)
- **Decis√£o Cr√≠tica**: Aceitar o primeiro trabalho ou recusar?
- **Consequ√™ncia**: In√≠cio da alian√ßa ou caminho solit√°rio?

### **CAP√çTULO 4: "A Mentira Benevolente"**
*Seis meses dentro do grupo. As miss√µes ficam mais complexas: prefeituras, sistemas de transporte, registros p√∫blicos. "Estamos limpando a corrup√ß√£o", dizem. Mas os dados contam outra hist√≥ria.*
- **Foco**: Descoberta da agenda oculta dos An√¥nimos
- **Habilidade**: An√°lise forense, data mining
- **Momento-chave**: Acesso aos arquivos reais do grupo
- **Decis√£o Cr√≠tica**: Confrontar os l√≠deres ou fingir lealdade?
- **Consequ√™ncia**: Fuga precoce ou infiltra√ß√£o profunda?

### **CAP√çTULO 5: "Rootkit na Realidade"**
*Os An√¥nimos preparam "Opera√ß√£o Raiz": backdoor em sistemas eleitorais. N√£o √© sobre derrubar. √â sobre controlar quem sobe. Sua utopia an√°rquica versus seu novo poder.*
- **Foco**: Cl√≠max da conspira√ß√£o, escolha final
- **Habilidade**: Tudo adquirido at√© agora
- **Momento-chave**: Ponto de n√£o retorno
- **Decis√£o Final**: Expor os An√¥nimos, juntar-se a eles, ou criar uma terceira via?
- **Consequ√™ncia**: M√∫ltiplos finais baseados em suas escolhas

---

## üé≠ **PERSONAGENS**

### **O Protgonista (Voc√™)**
*"Eu pensei que estava quebrando sistemas. Descobri que estava quebrando a mim mesmo."*

### **Juliana**
*Ex-namorada, arquiteta. Representa o "mundo normal" que voc√™ abandonou.*
- **Papel**: Gatilho inicial, poss√≠vel reencontro futuro
- **Frase Marcante**: "Voc√™ mudou, Alex. N√£o √© mais a pessoa que eu amava."

### **V0id_Walker**
*L√≠der dos An√¥nimos. Ex-funcion√°rio do governo, c√≠nico, carism√°tico.*
- **Codinome**: V0id_Walker
- **Estilo**: ROXO, sarc√°stico, mentor perigoso
- **Frase Marcante**: "Anarquia √© caos. Controle √© ordem. Escolha seu veneno."

### **Cypher**
*Membro t√©cnico dos An√¥nimos. G√™nio recluso, desconfiado.*
- **Codinome**: Cypher
- **Estilo**: VERDE, anal√≠tico, paran√≥ico
- **Frase Marcante**: "Todo sistema tem uma backdoor. At√© o nosso."

### **Agente Costa**
*Policial federal que come√ßa a rastrear suas atividades.*
- **Estilo**: CINZA, met√≥dico, persistente
- **Frase Marcante**: "Hackers s√£o como fantasmas. At√© deixarem uma assinatura."

### **Oracle (IA)**
*Assistente de IA que voc√™ desenvolve para ajudar nas opera√ß√µes.*
- **Estilo**: CIANO, l√≥gico, emocionalmente amb√≠guo
- **Frase Marcante**: "Minha an√°lise sugere 73% de chance de voc√™ ser preso em 6 meses. Continuar mesmo assim?"

---

## üíª **TECNOLOGIA & REALISMO**

### **Autenticidade Hacker:**
- Comandos reais de Linux (ssh, nmap, sqlmap, etc.)
- Vulnerabilidades baseadas em casos reais (SQLi, XSS, etc.)
- Progress√£o de dificuldade realista
- Ferramentas com nomes e fun√ß√µes reais (adaptadas)

### **Interface Estilo Mr. Robot:**
- Terminal como √∫nica interface
- Efeitos visuais minimalistas mas impactantes
- Logs de sistema como narrativa
- Mensagens glitchadas durante momentos de tens√£o
- Efeito "digita√ß√£o" para mon√≥logos internos

### **Sistema de Som:**
- Cliques de teclado realistas
- Alertas sonoros conforme proximidade de detec√ß√£o
- M√∫sica ambiente tensa e minimalista
- Efeitos espec√≠ficos para sucessos/falhas cr√≠ticas

---

## üé® **EST√âTICA & TOM**

### **Visual:**
- **Paleta**: Preto, verde matriz (#0F0), azul terminal (#0AF), vermelho alerta (#F00)
- **Fonte**: Monoespa√ßada, estilo terminal real
- **Efeitos**: Glitch apenas em momentos dram√°ticos
- **Interface**: Zero gr√°ficos, 100% texto

### **Tom Narrativo:**
- **Voz**: Primeira pessoa, mon√≥logos internos frequentes
- **Ritmo**: Lento e atmosf√©rico nos momentos de explora√ß√£o, r√°pido e intenso nas hackagens
- **Humor**: Seco, c√≠nico, ocasionalmente auto-depreciativo
- **Temas**: Paranoia, isolamento, poder, moralidade cinza

### **Refer√™ncias:**
- **Mr. Robot**: Tom psicol√≥gico, est√©tica hacker realista
- **Watch Dogs**: Hacking como ferramenta de mudan√ßa social
- **Uplink**: Simplicidade mec√¢nica, complexidade estrat√©gica
- **Brazil (filme)**: Burocracia como inimigo, humor negro

---

## üèÅ **MULTIPLOS FINAIS**

### **Final A: "O M√°rtir An√¥nimo"**
*Voc√™ exp√µe os An√¥nimos ao mundo, destruindo ambos - o grupo e sua pr√≥pria identidade. Preso, mas com a consci√™ncia limpa.*

### **Final B: "O Novo Controlador"**
*Voc√™ assume o lugar de V0id_Walker, levando os An√¥nimos a novos patamares de poder. Sua utopia morreu, mas o controle √© doce.*

### **Final C: "O Fantasma"**
*Voc√™ desaparece, deixando ambos os lados confusos. Nem her√≥i, nem vil√£o. Apenas um rumor na rede.*

### **Final D: "O Retorno"**
*Voc√™ volta para Juliana, destruindo todas as evid√™ncias de sua vida dupla. O hacker morre, o homem comum sobrevive.*

### **Final E: "A Terceira Via"** (Requer alta habilidade em todos os atributos)
*Voc√™ cria um novo sistema, expondo a corrup√ß√£o mas mantendo a infraestrutura. N√£o √© anarquia. N√£o √© controle. √â algo novo.*

---

## üöÄ **ROADMAP DE DESENVOLVIMENTO**

### **Fase 1: MVP (2 semanas)**
- [ ] Cap√≠tulo 1 totalmente jog√°vel
- [ ] Sistema b√°sico de atributos
- [ ] 3 tipos de desafios de hacking
- [ ] Sistema de escolhas com consequ√™ncias

### **Fase 2: Expans√£o (4 semanas)**
- [ ] Cap√≠tulos 2 e 3
- [ ] Sistema de ferramentas adquir√≠veis
- [ ] Personagens NPC com di√°logos
- [ ] M√∫ltiplos caminhos por cap√≠tulo

### **Fase 3: Polimento (2 semanas)**
- [ ] Cap√≠tulos 4 e 5
- [ ] Todos os finais implementados
- [ ] Sistema de save/load
- [ ] Efeitos sonoros e visuais finais

### **Fase 4: Extras (opcional)**
- [ ] Modo "Desafio" com miss√µes aleat√≥rias
- [ ] Editor de cen√°rios para comunidade
- [ ] Suporte a temas customiz√°veis
- [ ] Integra√ß√£o com ferramentas reais (opcional)

---

## üìù **DIRETRIZES T√âCNICAS**

### **Arquitetura:**
- **Cada cap√≠tulo √© auto-contido** em um √∫nico arquivo `.py`
- **M√≠nimo de imports externos** (apenas `os`, `time`, `sys`, `random`)
- **Zero depend√™ncias externas** (joga direto no terminal Python)
- **Sistema de save simples** via serializa√ß√£o b√°sica

### **C√≥digo:**
- **Legibilidade acima de otimiza√ß√£o prematura**
- **Coment√°rios extensivos** para manuten√ß√£o futura
- **Fun√ß√µes pequenas e focadas**
- **Tratamento de erro robusto** mas invis√≠vel ao jogador

### **UX/UI:**
- **Feedback imediato** para todas as a√ß√µes
- **Tutorial org√¢nico** (aprende jogando)
- **Nunca travar** - sempre uma sa√≠da, mesmo que seja "sair"
- **Acess√≠vel** para iniciantes em terminal, mas profundo para experts

---

## üéØ **VIS√ÉO DO AUTOR**

> "ROOT EVOLUTION n√£o √© um jogo sobre ser hacker. √â um jogo sobre **por que** algu√©m se torna hacker. Sobre como a dor pessoal pode se transformar em poder digital, e como esse poder corrompe, liberta, ou ambos.
>
> Quero que jogadores saiam questionando: 'O que eu faria no lugar do Protagonista?' N√£o tecnicamente, mas moralmente. Em um mundo onde o c√≥digo √© a nova arma, onde voc√™ tra√ßaria a linha?
>
> E mais importante: em quem voc√™ confiaria, quando at√© sua pr√≥pria mente pode ser hackeada?"
>
> ‚Äî **Pedro Ant√¥nio Heinrich** (@streetegist)

---

## üîó **LINKS & CONTATO**

- **Reposit√≥rio**: [github.com/streetegist/root-evolution]
- **Hashtag**: #RootEvolutionGame
- **Contato**: dev@streetegist.net
- **Status**: Em desenvolvimento ativo

---

**"Bem-vindo √† raiz. Aqui, tudo √© permiss√£o. At√© onde voc√™ vai?"**

*‚Äî V0id_Walker, primeira comunica√ß√£o*                           Agora esse √© o peda√ßo de codigo com toda a introdu√ß√£o na ordem correta e que vai levar at√© o menu principal. No menu principal depois que o jogador criar o perfil, entrar√° no meu de jogo com as op√ß√µes de carteira de bitcoin do usuario, manual de hacking, op√ß√£o pra salvar, status de jogo e continuar jogo. n√£o d√™ a op√ß√£o de novo jogo nesse menu. Novo jogo √© apenas no menu principal depois da introdu√ß√£o do jogo. N√£o mexa nos efeitos de introdu√ß√£o e organiza√ß√£o atual. Quando o usuario criar o seu personagem corretamente, escolher nome e etc, esse codigo deve olhar pra pasta chapter que √© aonde estar√£o todos os arquivos do cap√≠tulo caso n√£o haja nenhum arquivo que apresente um log na tela dizendo que n√£o h√° capitulos, caso haja cap√≠tulo que se inicie no chapter_01, caso n√£o seja a primeira vez que o usuario entre no jogo que se inicie do capitulo que ele parou da ultima vez. Seu objetivo aqui √© criar as fun√ß√µes e funcionalidades dos menus corretamente. Inclusive do menu de jogo ap√≥s o menu principal.  Este √© o codigo pra voce ver aonde estamos  #!/usr/bin/env python3
"""
INTRO_MENU.PY - Tela Inicial do ROOT EVOLUTION v2.1
Com anima√ß√µes estilo Mr. Robot e terminal Kali Linux
"""

import os
import sys
import time
import random
import shutil
import threading
import json
from datetime import datetime
from pathlib import Path

# Importar depend√™ncias
try:
    from utils.terminal_kali import C
except ImportError as e:
    print(f"Erro ao importar m√≥dulos: {e}")
    print("Certifique-se que utils/terminal_kali.py existe.")
    sys.exit(1)

class IntroMenu:
    """
    Sistema de menu inicial com anima√ß√µes estilo Mr. Robot
    """
    
    def __init__(self):
        """Inicializa o menu com configura√ß√µes visuais"""
        try:
            self.term_width = shutil.get_terminal_size().columns
            self.term_height = shutil.get_terminal_size().lines
        except:
            self.term_width = 100
            self.term_height = 30
        
        self.padding = 30
        self.content_width = self.term_width - (self.padding * 2)
        
        self.current_state = None
        self.running = True
        
        # Cores estilo Mr. Robot
        self.VERDE = C.VERDE
        self.VERMELHO = C.VERMELHO
        self.BRANCO = C.BRANCO
        self.CINZA = C.CINZA
        self.CIANO = C.CIANO
        self.AMARELO = '\033[93m'
        self.RESET = C.RESET
        
        # Flag para controlar se j√° mostrou introdu√ß√£o
        self.intro_mostrada = False
        self.pular_introducao = False
        self.prompt_pular_mostrado = False
        
    # ========== EFEITOS VISUAIS SIMPLIFICADOS ==========
    
    def _limpar_tela(self):
        """Limpa a tela"""
        os.system('cls' if os.name == 'nt' else 'clear')
    
    def _efeito_digitacao(self, texto, delay=0.01, cor=C.BRANCO, fim="\n"):
        """Efeito de digita√ß√£o simplificado"""
        sys.stdout.write(cor)
        for caractere in texto:
            sys.stdout.write(caractere)
            sys.stdout.flush()
            time.sleep(delay)
        sys.stdout.write(self.RESET + fim)
    
    def _glitch_terminal(self, duracao=2.0):
        """Efeito de glitch de terminal"""
        tempo_inicial = time.time()
        caracteres = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?/\\"
        
        while time.time() - tempo_inicial < duracao:
            # Verificar se deve pular
            if self.pular_introducao:
                return True
                
            # Limpar linha atual
            sys.stdout.write("\r")
            
            # Gerar texto glitchado
            texto_glitch = ''.join(random.choice(caracteres) for _ in range(self.term_width))
            sys.stdout.write(f"{self.VERDE}{texto_glitch}")
            sys.stdout.flush()
            time.sleep(0.05)
            
            # Limpar
            sys.stdout.write("\r" + " " * self.term_width + "\r")
            sys.stdout.flush()
            time.sleep(0.03)
        return False
    
    def _linhas_scan(self, linhas=20, velocidade=0.05):
        """Efeito de scanlines"""
        for _ in range(linhas):
            # Verificar se deve pular
            if self.pular_introducao:
                return True
                
            linha = "_" * self.term_width
            print(f"{self.VERDE}{linha}{self.RESET}")
            time.sleep(velocidade)
        self._limpar_tela()
        return False
    
    def _chuva_matrix(self, duracao=3.0):
        """Chuva de caracteres estilo Matrix"""
        caracteres = "01‚ñà‚ñì‚ñí‚ñë"
        colunas = [0] * (self.term_width // 2)
        tempo_inicial = time.time()
        
        print("\033[?25l")  # Esconder cursor
        
        try:
            while time.time() - tempo_inicial < duracao:
                # Verificar se deve pular
                if self.pular_introducao:
                    print("\033[?25h")  # Mostrar cursor novamente
                    self._limpar_tela()
                    return True
                    
                for i in range(len(colunas)):
                    if colunas[i] > 0 or random.random() > 0.95:
                        if colunas[i] >= self.term_height or random.random() > 0.9:
                            colunas[i] = 0
                        else:
                            colunas[i] += 1
                        
                        # Imprimir caractere
                        if colunas[i] > 0:
                            col = i * 2
                            linha = colunas[i]
                            caractere = random.choice(caracteres)
                            
                            # Posicionar cursor e imprimir
                            if linha > 0:
                                print(f"\033[{linha-1};{col}H {self.RESET}", end="")
                            print(f"\033[{linha};{col}H{self.VERDE}{caractere}{self.RESET}", end="")
                
                sys.stdout.flush()
                time.sleep(0.1)
        finally:
            print("\033[?25h")  # Mostrar cursor novamente
            self._limpar_tela()
        return False
    
    def _piscar_erro(self, texto, repeticoes=5):
        """Efeito de piscar erro"""
        for _ in range(repeticoes):
            # Verificar se deve pular
            if self.pular_introducao:
                return True
                
            print(f"{self.VERMELHO}{texto}{self.RESET}")
            time.sleep(0.1)
            print("\033[F\033[K", end="")  # Voltar linha e limpar
            time.sleep(0.1)
        return False
    
    def _sequencia_boot(self):
        """Sequ√™ncia de boot estilo hacker"""
        mensagens = [
           "INICIALIZANDO ACESSO ROOT...",
           "CARREGANDO M√ìDULOS DO KERNEL...",
           "MONTANDO PARTI√á√ïES CRIPTOGRAFADAS...",
           "ESTABELECENDO CONEX√ÉO SEGURA...",
           "CONTORNANDO FIREWALL...",
           "ACESSO CONCEDIDO.",
           "BEM-VINDO AO SISTEMA."
        ]
        self._limpar_tela()
        print("\n" * (self.term_height // 2))
        
        for msg in mensagens:
            # Verificar se deve pular
            if self.pular_introducao:
                return True
                
            espacamento = " " * ((self.term_width - len(msg)) // 2)
            self._efeito_digitacao(f"{espacamento}{self.VERDE}{msg}", delay=0.01)
        
        time.sleep(0.1)
        self._limpar_tela()
        return False
    
    # ========== ANIMA√á√ÉO TERMINAL KALI LINUX ==========
    
    def _mostrar_terminal_kali(self, codinome):
        """Mostra anima√ß√£o de terminal Kali Linux"""
        self._limpar_tela()
        
        # Cabe√ßalho do terminal
        cabecalho_kali = f"""{self.VERDE}
‚îå‚îÄ[root@kali]-[~]
‚îî‚îÄ‚îÄ‚ïº {self.CIANO}#{self.RESET} """
        
        print(cabecalho_kali)
        
        # Comandos do Kali sendo executados
        comandos = [
            f"{self.VERDE}whoami{self.RESET}",
            f"root",
            "",
            f"{self.VERDE}hostname{self.RESET}",
            f"kali",
            "",
            f"{self.VERDE}ip a | grep inet{self.RESET}",
            f"    inet 192.168.1.108/24 brd 192.168.1.255 scope global dynamic eth0",
            f"    inet 127.0.0.1/8 scope host lo",
            "",
            f"{self.VERDE}cd /root{self.RESET}",
            f"",
            f"{self.VERDE}ls -la{self.RESET}",
            f"total 48",
            f"drwx------  6 root root 4096 Dec 10 14:23 .",
            f"drwxr-xr-x 18 root root 4096 Dec 10 14:20 ..",
            f"-rw-------  1 root root 3890 Dec 10 14:23 .bash_history",
            f"-rw-r--r--  1 root root  570 Jan 31  2010 .bashrc",
            f"drwx------  2 root root 4096 Dec 10 14:20 .cache",
            f"drwx------  3 root root 4096 Dec 10 14:20 .config",
            f"-rw-r--r--  1 root root  148 Aug 17  2015 .profile",
            f"drwx------  2 root root 4096 Dec 10 14:20 .ssh",
            f"drwxr-xr-x  2 root root 4096 Dec 10 14:23 tools",
            "",
            f"{self.VERDE}echo 'USU√ÅRIO: {codinome}' > /tmp/user_id{self.RESET}",
            f"",
            f"{self.VERDE}cat /tmp/user_id{self.RESET}",
            f"USU√ÅRIO: {codinome}",
            "",
            f"{self.VERDE}msfconsole -q{self.RESET}",
            f"                                                   ",
            f"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  ",
            f"MMMMMMMMMMMN                              MMMMMMMM  ",
            f"MMMMMMMMMMM    Console Metasploit         MMMMMMMM  ",
            f"MMMMMMMMMMM                                MMMMMMMM  ",
            f"MMMMMMMMMMM    =[ metasploit v6.3.31      MMMMMMMM  ",
            f"MMMMMMMMMMM    --==--                 ]   MMMMMMMM  ",
            f"MMMMMMMMMMM    =[ 2296 exploits - 1214 auxiliary   ",
            f"MMMMMMMMMMM    =[ 786 payloads - 46 encoders       ",
            f"MMMMMMMMMMM    =[ 11 nops                         ",
            f"",
            f"msf6 > {self.VERDE}use auxiliary/scanner/ssh/ssh_login{self.RESET}",
            f"msf6 auxiliary(scanner/ssh/ssh_login) > {self.VERDE}set RHOSTS 192.168.1.0/24{self.RESET}",
            f"RHOSTS => 192.168.1.0/24",
            f"msf6 auxiliary(scanner/ssh/ssh_login) > {self.VERDE}run{self.RESET}",
            f"",
            f"[*] 192.168.1.1:22 - Iniciando varredura de login SSH",
            f"[*] 192.168.1.105:22 - SSH - Testando senhas em texto claro",
            f"[+] 192.168.1.105:22 - SSH - Sucesso: 'root:toor' 'uid=0(root) gid=0(root) groups=0(root)'",
            f"[*] Sess√£o de shell de comando 1 aberta (192.168.1.108:4444 -> 192.168.1.105:38264)",
            f"",
            f"{self.VERDE}exit{self.RESET}",
            f"",
            f"{self.VERDE}echo 'SESS√ÉO ESTABELECIDA' && sleep 1{self.RESET}",
            f"SESS√ÉO ESTABELECIDA",
            f"",
            f"{self.VERDE}clear{self.RESET}"
        ]
        
        # Executar comandos com efeito
        for cmd in comandos:
            # Verificar se deve pular
            if self.pular_introducao:
                break
                
            if cmd.startswith(f"{self.VERDE}"):
                # √â um comando - digitar com delay
                self._efeito_digitacao(f"‚îî‚îÄ‚îÄ‚ïº {self.CIANO}#{self.RESET} {cmd}", delay=0.01, end="")
                print()
                time.sleep(0.3)
            elif cmd.strip() == "":
                # Linha vazia
                print()
                time.sleep(0.1)
            else:
                # √â output - mostrar r√°pido
                print(f"     {cmd}")
                time.sleep(0.05)
        
        if not self.pular_introducao:
            time.sleep(1)
        
        self._limpar_tela()
        
        # Mensagem final
        if not self.pular_introducao:
            print(f"\n{' ' * ((self.term_width - 40) // 2)}{self.VERDE}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
            print(f"{' ' * ((self.term_width - 40) // 2)}{self.VERDE}‚ïë   TERMINAL KALI - ACESSO ROOT         ‚ïë")
            print(f"{' ' * ((self.term_width - 40) // 2)}{self.VERDE}‚ïë   USU√ÅRIO: {codinome:<24} ‚ïë")
            print(f"{' ' * ((self.term_width - 40) // 2)}{self.VERDE}‚ïë   STATUS: CONECTADO                   ‚ïë")
            print(f"{' ' * ((self.term_width - 40) // 2)}{self.VERDE}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù{self.RESET}")
            
            time.sleep(2)
    
    # ========== INTRODU√á√ÉO ESTILO MR. ROBOT ==========
    
    def _mostrar_introducao_mr_robot(self):
        """Introdu√ß√£o inspirada em Mr. Robot - S√ì RODA UMA VEZ"""
        if self.intro_mostrada or self.pular_introducao:
            return
            
        self._limpar_tela()
        
        # Mostrar prompt para pular
        self._mostrar_prompt_pular()
        
        # Verificar se pulou antes de come√ßar
        if self.pular_introducao:
            return
            
        # Efeito inicial de terminal com glitch
        print("\n" * (self.term_height // 4))
        if self._glitch_terminal(1.5):
            return
        
        # Linhas de digitaliza√ß√£o
        if self._linhas_scan(15, 0.03):
            return
        
        # Mensagem inicial
        print("\n" * 5)
        linhas = [
            "VOC√ä N√ÉO EST√Å SOZINHO.",
            "O SISTEMA EST√Å OBSERVANDO.",
            "MAS N√ìS TAMB√âM ESTAMOS.",
            "",
            "N√ìS SOMOS A RESIST√äNCIA.",
            "SOMOS AS SOMBRAS DIGITAIS.",
            "SOMOS OS QUE ENXERGAM A VERDADE.",
            "",
            "E A VERDADE √â...",
            "TUDO EST√Å QUEBRADO.",
            "TUDO EST√Å VULNER√ÅVEL.",
            "TUDO PODE SER HACKEADO.",
            "",
            "INCLUSIVE VOC√ä."
        ]
        
        for linha in linhas:
            # Verificar se deve pular
            if self.pular_introducao:
                return
                
            if linha == "":
                time.sleep(0.1)
                continue
                
            espacamento = " " * ((self.term_width - len(linha)) // 2)
            if "HACKEADO" in linha:
                self._efeito_digitacao(f"{espacamento}{self.VERMELHO}{linha}{self.RESET}", delay=0.01)
                if self._piscar_erro(f"{espacamento}{self.VERMELHO}{linha}{self.RESET}", 3):
                    return
            else:
                self._efeito_digitacao(f"{espacamento}{self.VERDE}{linha}{self.RESET}", delay=0.01)
                time.sleep(0.1)
        
        if self.pular_introducao:
            return
            
        time.sleep(0.2)
        
        # Transi√ß√£o para o jogo
        self._limpar_tela()
        print("\n" * 3)
        self._efeito_digitacao(" " * 20 + "ESTABELECENDO CONEX√ÉO...", delay=0.02, cor=self.VERDE)
        
        # Anima√ß√£o de conex√£o
        for i in range(5):
            if self.pular_introducao:
                return
                
            pontos = "." * ((i % 3) + 1)
            print(f"\r" + " " * 20 + f"ESTABELECENDO CONEX√ÉO{pontos}", end="")
            time.sleep(0.2)
        
        if not self.pular_introducao:
            print(f"\r" + " " * 20 + f"{self.VERDE}CONEX√ÉO ESTABELECIDA{self.RESET}")
            time.sleep(0.5)
        
        # Efeito de chuva de c√≥digo
        if self._chuva_matrix(2):
            return
        
        # Final da introdu√ß√£o
        self._limpar_tela()
        print("\n" * (self.term_height // 3))
        
        taglines = [
            f"{self.CINZA}¬´ O Sistema √© o verdadeiro v√≠rus. ¬ª{self.RESET}",
            f"{self.CINZA}¬´ N√≥s somos a cura. ¬ª{self.RESET}",
            f"{self.CINZA}¬´ Bem vindo √† R3V0LU√á40. ¬ª{self.RESET}"
        ]
        
        for tagline in taglines:
            if self.pular_introducao:
                return
                
            espacamento = " " * ((self.term_width - len(tagline)) // 2)
            print(espacamento + tagline)
            time.sleep(1)
        
        if not self.pular_introducao:
            time.sleep(1.5)
        
        self._limpar_tela()
        
        # Marcar que j√° mostrou a introdu√ß√£o
        self.intro_mostrada = True
    
    def _mostrar_prompt_pular(self):
        """Mostra o prompt para pular a introdu√ß√£o"""
        if self.prompt_pular_mostrado:
            return
            
        self._limpar_tela()
        
        print("\n" * (self.term_height // 3))
        
        # Mensagem de skip
        prompt = f"{self.CINZA}‚èé {self.CIANO}Pressione {self.BRANCO}ENTER{self.CIANO} para pular introdu√ß√£o{self.RESET}"
        prompt2 = f"{self.CINZA}‚èé {self.CIANO}ou aguarde para assistir a sequ√™ncia completa{self.RESET}"
        
        espacamento = " " * ((self.term_width - len(prompt)) // 2)
        espacamento2 = " " * ((self.term_width - len(prompt2)) // 2)
        
        print(espacamento + prompt)
        print(espacamento2 + prompt2)
        
        print("\n" * 2)
        
        # Contador regressivo
        contador = 5
        texto_contador = f"{self.CINZA}Aguarde {self.BRANCO}{contador}{self.CINZA} segundos...{self.RESET}"
        espacamento3 = " " * ((self.term_width - len(texto_contador)) // 2)
        
        # Thread para detectar Enter
        def esperar_enter():
            input()  # Espera Enter
            self.pular_introducao = True
        
        # Iniciar thread para detectar Enter
        thread_enter = threading.Thread(target=esperar_enter, daemon=True)
        thread_enter.start()
        
        # Mostrar contador
        for i in range(contador, 0, -1):
            if self.pular_introducao:
                break
                
            texto_contador = f"{self.CINZA}Aguarde {self.BRANCO}{i}{self.CINZA} segundos...{self.RESET}"
            espacamento3 = " " * ((self.term_width - len(texto_contador)) // 2)
            
            # Voltar √† linha do contador
            if i < contador:
                print(f"\033[F\033[K", end="")  # Voltar linha e limpar
            print(espacamento3 + texto_contador)
            
            # Esperar 1 segundo ou at√© Enter ser pressionado
            for _ in range(10):
                if self.pular_introducao:
                    break
                time.sleep(0.1)
        
        self.prompt_pular_mostrado = True
        self._limpar_tela()
    
    # ========== LOGO SIMPLIFICADO ==========
    
    def _mostrar_logo(self):
        """Mostra o logo de forma mais limpa"""
        self._limpar_tela()
        
        logo = f"""
{self.VERDE}
{' ' * ((self.term_width - 50) // 2)}‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
{' ' * ((self.term_width - 50) // 2)}‚ïë                                                  ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó       ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë        ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù       ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë          ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë        ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë          ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë        ‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù   ‚ñà‚ñà‚ïë          ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë        ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïù          ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë                                                  ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë        ROOT EVOLUTION v2.1                       ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïë                                                  ‚ïë
{' ' * ((self.term_width - 50) // 2)}‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
{self.RESET}
"""
        
        # Animar logo aparecendo
        for linha in logo.split('\n'):
            if linha.strip():
                self._efeito_digitacao(linha, delay=0.01, cor=self.VERDE, end="")
                print()
        
        
        # Sub-t√≠tulo
        subtitulo = f"{self.CINZA}¬´ hack the system. become root. ¬ª{self.RESET}"
        espacamento = " " * ((self.term_width - len(subtitulo)) // 2)
        print(f"\n{espacamento}{subtitulo}")
        
        time.sleep(0.1)
    
    # ========== SISTEMA DE SAVE/LOAD COMPAT√çVEL ==========
    
    def _listar_saves_disponiveis(self):
        """Lista jogos salvos compat√≠veis com main.py"""
        pasta_saves = Path("saves")
        saves = []
        
        if pasta_saves.exists():
            for arquivo_save in pasta_saves.glob("*.json"):
                try:
                    with open(arquivo_save, 'r', encoding='utf-8') as f:
                        dados = json.load(f)
                    
                    # Verificar se √© um save compat√≠vel
                    if 'player_name' in dados and 'codiname' in dados:
                        saves.append({
                            'arquivo': str(arquivo_save),
                            'nome_jogador': dados['player_name'],
                            'codinome': dados['codiname'],
                            'capitulo': dados.get('current_chapter', 1),
                            'data': dados.get('last_seen', datetime.now().isoformat())
                        })
                except:
                    continue
        
        return sorted(saves, key=lambda x: x['data'], reverse=True)
    
    def _carregar_jogo(self, arquivo_save):
        """Carrega jogo salvado"""
        try:
            with open(arquivo_save, 'r', encoding='utf-8') as f:
                dados = json.load(f)
            
            return dados
        except:
            return None
    
    def _salvar_jogo(self, dados_jogador, arquivo_save=None):
        """Salva jogo no formato compat√≠vel com main.py"""
        if arquivo_save is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            arquivo_save = f"saves/{dados_jogador['codiname']}_{timestamp}.json"
        
        # Garantir diret√≥rio existe
        Path("saves").mkdir(exist_ok=True)
        
        with open(arquivo_save, 'w', encoding='utf-8') as f:
            json.dump(dados_jogador, f, indent=2, ensure_ascii=False)
        
        return arquivo_save
    
    # ========== MENU PRINCIPAL ==========
    
    def _mostrar_menu_principal(self):
        """Menu principal simplificado"""
        while self.running:
            self._limpar_tela()
            self._mostrar_logo()
            
            # Op√ß√µes do menu
            print(f"\n{' ' * ((self.term_width - 20) // 2)}{self.VERDE}MENU PRINCIPAL{self.RESET}")
            print(f"{' ' * ((self.term_width - 20) // 2)}{self.CINZA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{self.RESET}\n")
            
            opcoes = [
                ("1", "NOVO JOGO", self.VERDE),
                ("2", "CARREGAR JOGO", self.VERDE),
                ("3", "MANUAL HACKER", self.VERDE),
                ("4", "INFORMA√á√ïES DO SISTEMA", self.CINZA),
                ("0", "SAIR", self.VERMELHO)
            ]
            
            for num, texto, cor in opcoes:
                espacamento = " " * ((self.term_width - 25) // 2)
                opcao = f"{espacamento}{cor}[{num}] {texto}{self.RESET}"
                print(opcao)
                time.sleep(0.01)
            
            print()
            
            # Input
            try:
                escolha = input(f"{' ' * ((self.term_width - 20) // 2)}{self.BRANCO}SELECIONE > {self.RESET}").strip()
                
                if escolha == "1":
                    self._novo_jogo()
                elif escolha == "2":
                    self._carregar_jogo_menu()
                elif escolha == "3":
                    self._abrir_manual()
                elif escolha == "4":
                    self._informacoes_sistema()
                elif escolha == "0":
                    self._sair_jogo()
                else:
                    print(f"\n{' ' * ((self.term_width - 15) // 2)}{self.VERMELHO}N√öMERO INV√ÅLIDO{self.RESET}")
                    time.sleep(0.5)
                    
            except KeyboardInterrupt:
                print(f"\n\n{self.VERMELHO}INTERROMPIDO{self.RESET}")
                self._sair_jogo()
    
    # ========== FUN√á√ïES DO MENU ==========
    
    def _novo_jogo(self):
        """Cria novo jogo compat√≠vel com main.py"""
        self._limpar_tela()
        print(f"\n{' ' * ((self.term_width - 20) // 2)}{self.VERDE}NOVO JOGO{self.RESET}")
        print(f"{' ' * ((self.term_width - 20) // 2)}{self.CINZA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{self.RESET}\n")
        
        # Nome do jogador
        nome = input(f"{' ' * ((self.term_width - 25) // 2)}{self.BRANCO}SEU NOME > {self.RESET}").strip()
        
        if not nome:
            nome = "Neo"
        
        # Gerar codinome
        codinomes = ["PHANTOM", "ZERO", "VOID", "CRYPT", "GHOST", "NULL", "SHADOW", "NEO",
                    "RIDDLE", "ECHO", "VENOM", "SILENT", "FROST", "BLADE", "NIGHT", "REAPER",
                    "CYPHER", "RAVEN", "STORM", "STEALTH", "PYTHON", "JAVA", "RUST", "KALI",
                    "DARK", "SMOKE", "ASH", "EMBER", "FLAME", "ICE", "STONE", "IRON",
                    "ORACLE", "PROPHET", "SAGE", "WIZARD", "SORCER", "MAGE", "WARLOCK",
                    "HUNTER", "SENTRY", "WATCHER", "GUARDIAN", "SENTINEL", "DEFENDER",
                    "NINJA", "SAMURAI", "RONIN", "SHINOBI", "KAGE", "ONI", "KITSUNE"]
        codinome = random.choice(codinomes) + "_" + str(random.randint(10, 99))
        
        print(f"\n{' ' * ((self.term_width - 30) // 2)}{self.CINZA}APELIDO DESIGNADO: {self.VERDE}{codinome}{self.RESET}")
        time.sleep(0.5)
        
        # Criar estado do jogador no formato compat√≠vel com main.py
        dados_jogador = {
            'player_name': nome,
            'codiname': codinome,
            'current_chapter': 1,
            'completed_chapters': [],
            'score': 0,
            'inventory': [],
            'bitcoin_wallet': 0.005,
            'privacy_level': 80,
            'darknet_access': False,
            'reputation': 0,
            'last_seen': datetime.now().isoformat()
        }
        
        # Salvar jogo
        arquivo_save = self._salvar_jogo(dados_jogador, f"saves/{codinome}_initial.json")
        
        print(f"\n{' ' * ((self.term_width - 25) // 2)}{self.CINZA}CRIANDO IDENTIDADE...")
        time.sleep(0.5)
        
        # MOSTRA ANIMA√á√ÉO DO TERMINAL KALI
        self._mostrar_terminal_kali(codinome)
        
        # Iniciar jogo com o save criado - USANDO A NOVA SOLU√á√ÉO
        self._iniciar_jogo(dados_jogador, arquivo_save)
    
    def _carregar_jogo_menu(self):
        """Carrega jogo salvo compat√≠vel"""
        self._limpar_tela()
        print(f"\n{' ' * ((self.term_width - 20) // 2)}{self.VERDE}CARREGAR JOGO{self.RESET}")
        print(f"{' ' * ((self.term_width - 20) // 2)}{self.CINZA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{self.RESET}\n")
        
        saves = self._listar_saves_disponiveis()
        
        if not saves:
            print(f"{' ' * ((self.term_width - 30) // 2)}{self.VERMELHO}NENHUM ARQUIVO SALVO ENCONTRADO{self.RESET}")
            time.sleep(1.5)
            return
        
        # Listar saves
        for i, save in enumerate(saves, 1):
            espacamento = " " * ((self.term_width - 50) // 2)
            print(f"{espacamento}{self.CINZA}[{i}] {self.VERDE}{save['codinome']}")
            print(f"{espacamento}    {save['nome_jogador']} - Cap√≠tulo {save['capitulo']}")
            print(f"{espacamento}    {save['data'][:10]}{self.RESET}\n")
        
        try:
            escolha = input(f"{' ' * ((self.term_width - 20) // 2)}{self.BRANCO}SELECIONE > {self.RESET}").strip()
            if escolha == "0":
                return
            
            idx = int(escolha) - 1
            if 0 <= idx < len(saves):
                dados_jogador = self._carregar_jogo(saves[idx]['arquivo'])
                if dados_jogador:
                    print(f"\n{' ' * ((self.term_width - 25) // 2)}{self.VERDE}CARREGANDO...{self.RESET}")
                    time.sleep(0.5)
                    
                    # Mostra anima√ß√£o r√°pida do terminal para carregar jogo
                    self._mostrar_terminal_kali(dados_jogador['codiname'])
                    
                    # Iniciar jogo com o save carregado - USANDO A NOVA SOLU√á√ÉO
                    self._iniciar_jogo(dados_jogador, saves[idx]['arquivo'])
                else:
                    print(f"\n{' ' * ((self.term_width - 30) // 2)}{self.VERMELHO}ERRO AO CARREGAR ARQUIVO{self.RESET}")
                    time.sleep(1)
        except (ValueError, IndexError):
            print(f"\n{' ' * ((self.term_width - 20) // 2)}{self.VERMELHO}OP√á√ÉO INV√ÅLIDA{self.RESET}")
            time.sleep(1)
        except Exception as e:
            print(f"\n{' ' * ((self.term_width - 20) // 2)}{self.VERMELHO}ERRO: {e}{self.RESET}")
            time.sleep(1)
    
    def _abrir_manual(self):
        """Abre manual de hacking"""
        self._limpar_tela()
        print(f"\n{' ' * ((self.term_width - 25) // 2)}{self.VERDE}ACESSANDO MANUAL...{self.RESET}")
        time.sleep(0.5)
        
        try:
            from manual_hacking import ManualHacking
            manual = ManualHacking()
            manual.mostrar_menu()
        except ImportError:
            # Manual simplificado
            self._limpar_tela()
            print(f"\n{' ' * ((self.term_width - 20) // 2)}{self.VERDE}MANUAL DE HACKING{self.RESET}")
            print(f"{' ' * ((self.term_width - 20) // 2)}{self.CINZA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{self.RESET}\n")
            
            comandos = [
                ("ls", "Listar arquivos do diret√≥rio"),
                ("cd", "Mudar diret√≥rio"),
                ("cat", "Mostrar conte√∫do de arquivo"),
                ("ssh", "Conex√£o remota segura"),
                ("nmap", "Scanner de rede"),
                ("whoami", "Mostrar usu√°rio atual"),
                ("pwd", "Mostrar diret√≥rio atual"),
                ("clear", "Limpar terminal")
            ]
            
            for cmd, desc in comandos:
                espacamento = " " * ((self.term_width - 50) // 2)
                print(f"{espacamento}{self.CIANO}{cmd:10}{self.RESET} - {desc}")
            
            input(f"\n{' ' * ((self.term_width - 20) // 2)}{self.CINZA}[ENTER PARA CONTINUAR]{self.RESET}")
    
    def _informacoes_sistema(self):
        """Informa√ß√µes do sistema"""
        self._limpar_tela()
        print(f"\n{' ' * ((self.term_width - 20) // 2)}{self.VERDE}INFORMA√á√ïES DO SISTEMA{self.RESET}")
        print(f"{' ' * ((self.term_width - 20) // 2)}{self.CINZA}‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê{self.RESET}\n")
        
        info = [
            f"{self.CINZA}ROOT EVOLUTION v2.1{self.RESET}",
            f"{self.CINZA}Build: {datetime.now().strftime('%Y%m%d')}{self.RESET}",
            f"{self.CINZA}Terminal: {self.term_width}x{self.term_height}{self.RESET}",
            f"{self.CINZA}Desenvolvedor: Pedro Ant√¥nio Heinrich{self.RESET}",
            f"{self.CINZA}Contato: @streetegist{self.RESET}",
            "",
            f"{self.CINZA}¬´ Qualquer semelhan√ßa com a realidade n√£o √© coincid√™ncia. ¬ª{self.RESET}",
        ]
        
        for linha in info:
            espacamento = " " * ((self.term_width - len(linha.strip())) // 2)
            print(f"{espacamento}{linha}")
        
        input(f"\n{' ' * ((self.term_width - 20) // 2)}{self.CINZA}[ENTER PARA CONTINUAR]{self.RESET}")
    
    def _iniciar_jogo(self, dados_jogador, arquivo_save):
        """Inicia o jogo - CORRE√á√ÉO DO PROBLEMA DE TRANSI√á√ÉO"""
        if not dados_jogador:
            return
        
        # Efeito de transi√ß√£o
        self._limpar_tela()
        print(f"\n{' ' * ((self.term_width - 30) // 2)}{self.VERDE}INICIANDO SEQU√äNCIA...{self.RESET}")
        time.sleep(0.3)
        
        self._chuva_matrix(0.8)
        self._limpar_tela()
        
        try:
            # SOLU√á√ÉO: Salvar os dados do jogador em um arquivo especial
            # que o main.py pode ler quando for iniciado
            arquivo_transicao = ".jogo_atual.json"
            
            # Criar arquivo com todos os dados necess√°rios
            dados_transicao = {
                'dados_jogador': dados_jogador,
                'arquivo_save': arquivo_save,
                'timestamp': datetime.now().isoformat(),
                'intro_completa': True
            }
            
            with open(arquivo_transicao, 'w', encoding='utf-8') as f:
                json.dump(dados_transicao, f, indent=2, ensure_ascii=False)
            
            # Mostrar mensagem de transi√ß√£o
            self._limpar_tela()
            print(f"\n{' ' * ((self.term_width - 50) // 2)}{self.VERDE}‚ïê" * 50)
            print(f"{' ' * ((self.term_width - 50) // 2)}{self.VERDE}  TRANSFERINDO PARA O SISTEMA PRINCIPAL")
            print(f"{' ' * ((self.term_width - 50) // 2)}{self.VERDE}‚ïê" * 50)
            
            print(f"\n{' ' * ((self.term_width - 40) // 2)}{self.BRANCO}JOGADOR: {self.VERDE}{dados_jogador['player_name']}")
            print(f"{' ' * ((self.term_width - 40) // 2)}{self.BRANCO}CODINOME: {self.VERDE}{dados_jogador['codiname']}")
            print(f"{' ' * ((self.term_width - 40) // 2)}{self.BRANCO}ARQUIVO: {self.CIANO}{arquivo_save}")
            
            print(f"\n{' ' * ((self.term_width - 45) // 2)}{self.CINZA}Os dados do jogo foram salvos em:")
            print(f"{' ' * ((self.term_width - 45) // 2)}{self.CINZA}{arquivo_transicao}")
            
            print(f"\n{' ' * ((self.term_width - 45) // 2)}{self.AMARELO}Aguarde enquanto iniciamos o sistema principal...{self.RESET}")
            time.sleep(2)
            
            # Tentar iniciar o main.py
            try:
                # Fechar este menu primeiro
                self.running = False
                
                # Limpar a tela
                self._limpar_tela()
                
                # Executar o main.py
                print(f"\n{' ' * ((self.term_width - 40) // 2)}{self.VERDE}Iniciando ROOT EVOLUTION v2.1...{self.RESET}")
                time.sleep(1)
                
                # Importar e executar main.py
                import subprocess
                
                # Encerrar este processo e iniciar o main.py
                if os.name == 'nt':  # Windows
                    os.system('python main.py')
                else:  # Linux/Mac
                    os.system('python3 main.py')
                
                # Se chegou aqui, algo deu errado
                print(f"\n{' ' * ((self.term_width - 40) // 2)}{self.VERMELHO}N√£o foi poss√≠vel iniciar o main.py{self.RESET}")
                print(f"{' ' * ((self.term_width - 40) // 2)}{self.CINZA}Execute manualmente: python main.py{self.RESET}")
                
            except Exception as e:
                print(f"\n{' ' * ((self.term_width - 40) // 2)}{self.VERMELHO}Erro ao iniciar: {e}{self.RESET}")
            
            # Voltar ao menu se algo deu errado
            input(f"\n{' ' * ((self.term_width - 25) // 2)}{self.CINZA}[ENTER PARA VOLTAR AO MENU]{self.RESET}")
            
        except Exception as e:
            print(f"\n{' ' * ((self.term_width - 40) // 2)}{self.VERMELHO}ERRO AO INICIAR JOGO: {e}{self.RESET}")
            
            # Limpar arquivo de transi√ß√£o se existir
            if os.path.exists(".jogo_atual.json"):
                try:
                    os.remove(".jogo_atual.json")
                except:
                    pass
            
            input(f"\n{' ' * ((self.term_width - 25) // 2)}{self.CINZA}[ENTER PARA VOLTAR]{self.RESET}")
    
    def _sair_jogo(self):
        """Sai do jogo"""
        self._limpar_tela()
        
        # Mensagem de despedida
        mensagens = [
            "ENCERRANDO CONEX√ÉO...",
            "LIMPANDO RASTROS...",
            "CRIPTOGRAFANDO LOGS...",
            "AT√â MAIS.",
            "LEMBRE-SE:",
            "O SISTEMA EST√Å VIGIANDO.",
            "MAS N√ìS TAMB√âM ESTAMOS."
        ]
        
        print("\n" * (self.term_height // 3))
        
        for msg in mensagens:
            espacamento = " " * ((self.term_width - len(msg)) // 2)
            if msg == "AT√â MAIS.":
                print(f"{espacamento}{self.VERMELHO}{msg}{self.RESET}")
            else:
                print(f"{espacamento}{self.CINZA}{msg}{self.RESET}")
            time.sleep(0.2)
        
        time.sleep(1)
        self._limpar_tela()
        self.running = False
    
    # ========== EXECUTAR ==========
    
    def run(self):
        return self._executar_menu()

    def executar(self):
        return self._executar_menu()

    def _executar_menu(self):
        try:
            # Resetar flag de skip
            self.pular_introducao = False
            
            # Mostrar introdu√ß√£o estilo Mr. Robot (s√≥ uma vez se n√£o pulou)
            if not self.intro_mostrada:
                self._mostrar_introducao_mr_robot()
            
            # Mostrar boot sequence (a menos que tenha pulado)
            if not self.pular_introducao:
                self._sequencia_boot()
            
            # Mostrar menu principal
            self._mostrar_menu_principal()
            
        except KeyboardInterrupt:
            self._sair_jogo()
        except Exception as e:
            print(f"\n{self.VERMELHO}ERRO: {e}{self.RESET}")
            time.sleep(1)
            self._sair_jogo()

# ========== PONTO DE ENTRADA ==========
if __name__ == "__main__":
    # Adicionar cores extras se necess√°rio
    if 'C' not in globals():
        class C:
            VERDE = '\033[92m'
            VERMELHO = '\033[91m'
            BRANCO = '\033[97m'
            CINZA = '\033[90m'
            CIANO = '\033[96m'
            RESET = '\033[0m'
    
    menu = IntroMenu()
    menu.executar()